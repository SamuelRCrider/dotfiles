;;--------------------------------------------------------------------;
;; sly
;;--------------------------------------------------------------------;

(require 'patch-sly)
(with-eval-after-load 'sly-mrepl
  (require 'patch-sly-prompt))
(require 'cl-lib)

(require 'company)

(defun boogs/delete-lisp-image-dump ()
  "Delete SLY current connection image dump.
This dump is expected to be generated by `lisp-repl-core-dumper'."
  (interactive)
  (let* ((pid (process-id (sly-inferior-process (sly-current-connection))))
         (args (alist-get 'args (process-attributes pid)))
         (command (car (split-string (alist-get 'args (process-attributes pid))))))
    (if (and (string= "image"
                      (file-name-extension command))
             (string= (file-name-directory command)
                      (expand-file-name "~/.cache/lisp-repl-core-directory/")))
        (when (yes-or-no-p (format "Delete %s?" command))
          (let ((delete-by-moving-to-trash nil))
            (delete-file command)
            (message "%S deleted." command)))
      (message "%S is not a Lisp image dump." command))))

(load "~/projects/nyxt/build-scripts/nyxt-guix.el" :noerror)

;; Warning: ,restart-lisp does not take changes into account, the buffer must be re-created.
;; TODO: SLY: Add pre-inst-env SBCL, maybe ask for packages?
(setq sly-lisp-implementations
      (let* ((maybe-core-dumper (when-let ((exec (executable-find "lisp-repl-core-dumper")))
                                  (list exec)))
             (nyxt-ad-hoc-deps '("emacs"
                                 "git"
                                 "gnupg"
                                 "guix"
                                 "password-store"
                                 "xdg-utils"))
             (nyxt-command `("guix" "environment" "--pure"
                             "--preserve=^PERSONAL$" ; To find personal config, like engines and bookmarks.
                             "-l" ,(expand-file-name "~/common-lisp/nyxt/build-scripts/guix.scm")
                             ;; glib is needed to export GIO_EXTRA_MODULES.
                             "--ad-hoc" "glib"
                             ;; Not necessary?
                             "glib-networking" "gsettings-desktop-schemas"
                             ,@nyxt-ad-hoc-deps
                             ;; "--" "sbcl"
                             )))
        ;; TODO: Shouldn't lisp-repl-core-dumper include sb-sprof?  Should SBCL
        ;; packages remain loadable?
        `((sbcl-boogs ("lisp-repl-core-dumper" "-g" "--non-interactive"
                       "-s" "boogs" "sbcl"
                       "--eval" "(asdf:load-system :sb-sprof)"
                       "--eval" "(in-package :boogs/all)"
                       "--eval" "(named-readtables:in-readtable boogs/syntax:syntax)"))
          (sbcl (,@maybe-core-dumper "sbcl"))
          (sbcl-failsafe ("sbcl"))
          (sbcl-pre-inst-env ,(list (expand-file-name "~/projects/guix/pre-inst-env")
                                    "guix" "environment" "--ad-hoc" "sbcl" "sbcl-quickproject"
                                    "--" "sbcl"))
          (sbcl-nyxt (lambda ()
                       (nyxt-make-guix-sbcl-for-nyxt "~/projects/nyxt"
                                                     :preserve '("PERSONAL")
                                                     :ad-hoc ',nyxt-ad-hoc-deps)))
          (sbcl-nyxt-force (lambda ()
                             (nyxt-make-guix-sbcl-for-nyxt "~/projects/nyxt"
                                                           :preserve '("PERSONAL")
                                                           :ad-hoc ',nyxt-ad-hoc-deps
                                                           :force t)))
          (sbcl-nyxt-pre-inst-env ,(append
                                    (list (expand-file-name "~/projects/guix/pre-inst-env"))
                                    nyxt-command
                                    '("--" "sbcl")))
          ;; Simple REPL environment for Nyxt, in case sbcl-nyxt does not work.
          (sbcl-nyxt-failsafe ,(append nyxt-command '("--" "sbcl")))
          (ccl-nyxt ,(append nyxt-command '("ccl"
                                            "cl-osicat" ; Osicat is required by non-SBCL compilers.
                                            "--" "ccl")))
          (sbcl-nyxt-site ("guix" "environment" "--pure"
                           "-m" ,(expand-file-name "~/common-lisp/nyxt-site/guix-manifest.scm")
                           "--" "sbcl"))
          (ccl (,@maybe-core-dumper "ccl"))
          (clisp (,@maybe-core-dumper "clisp"))
          (ecl ("ecl")))))

(setq sly-connection-update-interval 0.1)

(when (require 'helm nil :noerror)
  (with-eval-after-load 'sly-mrepl
    (define-key sly-mrepl-mode-map (kbd "M-p") 'helm-comint-input-ring)
    (define-key sly-mrepl-mode-map (kbd "M-s f") 'helm-comint-prompts-all)
    (define-key sly-autodoc-mode-map (kbd "C-c C-d C-a") 'helm-sly-apropos)
    (define-key sly-mrepl-mode-map (kbd "C-c C-x c") 'helm-sly-list-connections)))

(when (require 'helm-sly nil :noerror)
  (when (require 'evil-collection nil :noerror)
    (evil-define-key '(normal insert) helm-sly-connections-map
      (kbd "S-<return>") 'helm-sly-run-go-to-repl-other-window))
  (defun boogs/helm-sly-format-connection (connection buffer)
    (let ((fstring "%s%2s  %s"))
      (format fstring
              (if (eq sly-default-connection connection)
                  "*"
                " ")
              (helm-sly-connection-number connection)
              (replace-regexp-in-string
               "*$" ""
               (replace-regexp-in-string
                "*sly-mrepl for " ""
                (replace-regexp-in-string "*sly-inferior-lisp for " ""
                                          (buffer-name buffer)))))))
  (setq helm-sly-connection-formatter #'boogs/helm-sly-format-connection)
  (global-helm-sly-mode)
  (add-to-list 'helm-source-names-using-follow "Lisp xrefs"))

(defun boogs/sly-insert-cmd ()
  "Convenient to call commands."
  (interactive)
  (insert "(cmd:cmd \"\")")
  (backward-char 2)
  (when (and (boundp 'evil-state)
             (not (eq evil-state 'insert)))
    (call-interactively #'evil-insert)))

(defun boogs/sly-insert-double-quotes ()
  "Convenient to write list of string, e.g. when writing a shell command line."
  (interactive)
  (while (sly-inside-string-p)
    (forward-char))
  (cycle-spacing)
  (insert "\"\"")
  (backward-char)
  (when (and (boundp 'evil-state)
             (not (eq evil-state 'insert)))
    (call-interactively #'evil-insert)))

(defun boogs/sly-insert-pipe ()
  "Convenient to write a `:-' pipe."
  (interactive)
  (while (sly-inside-string-p)
    (forward-char))
  (newline-and-indent)
  (insert ":-")
  (boogs/sly-insert-double-quotes))

;; Glyphs
(defun boogs/insert-lambda () (interactive) (insert "\u03bb"))
(defun boogs/insert-cursive-f () (interactive) (insert "\u0192"))
(defun boogs/insert-right-arrow () (interactive) (insert "\u2192"))
(defun boogs/insert-alpha () (interactive) (insert "\u03b1"))
(defun boogs/insert-psy () (interactive) (insert "\u03c8"))

(with-eval-after-load 'sly-mrepl
  (set-face-attribute 'sly-mrepl-output-face nil :inherit 'default :foreground)
  (setq sly-mrepl-history-file-name (expand-file-name "sly-mrepl-history" user-emacs-directory))
  (define-key sly-mrepl-mode-map (kbd "") 'sly-mrepl-set-package)
  ;; While `,i RET` is short enough, it's one more key away in Evil insert state:
  (define-key sly-mrepl-mode-map (kbd "RET") 'sly-mrepl-return-at-end)
  (define-key sly-mrepl-mode-map (kbd "C-c M-o") 'sly-mrepl-clear-repl)
  (define-key sly-mrepl-mode-map (kbd "S-SPC") 'boogs/sly-insert-double-quotes)
  (define-key sly-mrepl-mode-map (kbd "C-S-SPC") 'boogs/sly-insert-pipe)
  (define-key sly-mrepl-mode-map (kbd "<C-return>") 'boogs/sly-insert-cmd)
  ;; Glyphs
  (define-key sly-mrepl-mode-map (kbd "M-l") 'boogs/insert-lambda)
  (define-key sly-mrepl-mode-map (kbd "M-f") 'boogs/insert-cursive-f)
  (define-key sly-mrepl-mode-map (kbd "M-a") 'boogs/insert-alpha)
  (define-key sly-mrepl-mode-map (kbd "M->") 'boogs/insert-right-arrow)
  (define-key sly-mrepl-mode-map (kbd "<M-right>") 'boogs/insert-right-arrow)
  (define-key sly-mrepl-mode-map (kbd "C-M-y") 'boogs/insert-psy))

(defun boogs/sly-load-reload-system ()
  (interactive)
  (funcall
   (if (sly-eval `(slynk-asdf:asdf-system-loaded-p ,(intern (sly-current-package))))
       #'sly-asdf-reload-system
     #'sly-asdf-load-system)
   (intern (sly-current-package))))
(define-key lisp-mode-map (kbd "<f6>") 'boogs/sly-load-reload-system)

(defun boogs/sly-colorize-buffer (str)
  "Useful for colorized output like the tests of Prove."
  (ansi-color-apply str))
(add-hook 'sly-mrepl-output-filter-functions 'boogs/sly-colorize-buffer)

(defun boogs/indent-and-helm-company (arg)
  "Indent then call `helm-company'.
Good substitute for `sly-mrepl-indent-and-complete-symbol'."
  (interactive "P")
  (indent-for-tab-command arg)
  (helm-company))

(setq sly-command-switch-to-existing-lisp 'always)
(add-hook 'sly-mrepl-hook #'boogs/init-lispy)
(add-hook 'sly-mrepl-hook #'company-mode)
(add-hook 'sly-mrepl-hook #'rainbow-delimiters-mode)
(require 'patch-sly-rainbow)

;; #p completion.  See https://github.com/joaotavora/sly/issues/405.
(with-eval-after-load 'company
  (defcustom boogs/complete-cl-file-prefix "./"
    "Prefix for `boogs/complete-cl-file'."
    :type 'string)
  (defun boogs/complete-cl-file (action &rest _)
    (interactive (list 'interactive))
    (cl-case action
      (interactive (company-begin-backend #'my/complete-cl-file))
      (candidates
       (cond ((and (save-match-data (looking-back "#p" (- (point) 2))))
              (if (looking-at-p "\"")
                  (forward-char)
                (insert "\"")
                (save-excursion (insert "\"")))
              (company-files 'candidates boogs/complete-cl-file-prefix))
             ((save-match-data (looking-back "#p\"" (- (point) 3)))
              (company-files 'candidates boogs/complete-cl-file-prefix))))
      (prefix (and (save-match-data (looking-back "#p\"?")) ""))
      (t (company-files action))))

  (defun boogs/set-sly-company-backends ()
    (set (make-local-variable 'company-backends)
         (cons 'boogs/complete-cl-file company-backends)))
  (add-hook 'sly-mrepl-hook 'boogs/set-sly-company-backends))

;; REVIEW: With Emacs 27 we can:
;; (customize-set-variable 'helm-completion-style 'emacs)
;; (add-to-list 'completion-styles 'backend) ; Useless?
(when (require 'helm-sly nil 'noerror)
  (add-hook 'sly-mrepl-hook #'helm-sly-disable-internal-completion)
  ;; REVIEW: Company completion has the benefit of having annotations.
  ;; (when (require 'helm-company nil :noerror)
  ;;   (add-hook 'lisp-mode-hook #'company-mode)
  ;;   (define-key lisp-mode-map (kbd "<tab>") 'boogs/indent-and-helm-company)
  ;;   (define-key lisp-mode-map (kbd "M-<tab>") 'boogs/indent-and-helm-company)
  ;;   (defun boogs/sly-set-keys ()
  ;;     (define-key sly-mrepl-mode-map (kbd "<tab>") 'boogs/indent-and-helm-company)
  ;;     (define-key sly-mrepl-mode-map (kbd "M-<tab>") 'boogs/indent-and-helm-company))
  ;;   (add-hook 'sly-mrepl-hook #'boogs/sly-set-keys)
  ;;   (add-hook 'sly-mrepl-hook #'company-mode))
  )
;; Cons of internal completion vs. company completion.
;; - Internal does not support spaces like Helm does.
;; - Word order matters.
;; - Cannot complete against current package.
;; - [ ] File completion does not work.
;; Pros:
;; - Current suffix is included.
;; - Less config.


(when (require 'helm-selector nil :noerror)
  (require 'init-sly-selector))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Prompt customization
;; TODO: Upstream!

(defvar boogs/sly-status--last-command-time nil)
(make-variable-buffer-local 'boogs/sly-status--last-command-time)
(defun boogs/sly-status--record ()
  (setq boogs/sly-status--last-command-time (current-time)))

(defun boogs/sly-status-formatter (timestamp duration)
  "Return the status display for `boogs/sly-status'.
TIMESTAMP is the value returned by `current-time' and DURATION is the floating
time the command took to complete in seconds."
  (format "#[STATUS] End time %s, duration %.3fs\n"
          (format-time-string "%F %T" timestamp)
          duration))

(defcustom boogs/sly-status-min-duration 1
  "If a command takes more time than this, display its status with `boogs/sly-status'."
  :group 'sly
  :type 'number)

(defun boogs/sly-status (&optional formatter min-duration)
  "Termination timestamp and duration of command.
Status is only returned if command duration was longer than
MIN-DURATION \(defaults to `boogs/sly-status-min-duration').  FORMATTER
is a function of two arguments, TIMESTAMP and DURATION, that
returns a string."
  (if boogs/sly-status--last-command-time
      (let ((duration (time-to-seconds
                       (time-subtract (current-time) boogs/sly-status--last-command-time))))
        (setq boogs/sly-status--last-command-time nil)
        (if (> duration (or min-duration
                            boogs/sly-status-min-duration))
            (funcall (or formatter
                         #'boogs/sly-status-formatter)
                     (current-time)
                     duration)
          ""))
    (progn
      (advice-add 'sly-mrepl--send-input-sexp :after #'boogs/sly-status--record)
      "")))

(defun boogs/sly-prepare-prompt (old-func &rest args) ; TODO: Remove when upstream have merged `sly-mrepl-prompt-formatter'.
  (let ((package (nth 0 args))
        (new-prompt (format "%s%s\n%s"
                            (boogs/sly-status)
                            (abbreviate-file-name default-directory)
                            (nth 1 args)))
        (error-level (nth 2 args))
        (condition (nth 3 args)))
    (funcall old-func package new-prompt error-level condition)))

(cl-defun boogs/sly-new-prompt (_package
                                package-nickname
                                error-level
                                entry-idx
                                _condition)
  (concat
   (propertize (boogs/sly-status) 'font-lock-face 'font-lock-comment-face)
   "("
   (propertize (abbreviate-file-name default-directory) 'font-lock-face 'diff-added)
   ")\n"
   (propertize "<" 'font-lock-face 'sly-mrepl-prompt-face)
   (propertize (number-to-string entry-idx) 'font-lock-face 'sly-mode-line)
   (propertize ":" 'font-lock-face 'sly-mrepl-prompt-face)
   (propertize package-nickname 'font-lock-face 'sly-mode-line)
   (when (cl-plusp error-level)
     (concat (sly-make-action-button
              (format "[%d]" error-level)
              #'sly-db-pop-to-debugger-maybe)
             " "))
   (propertize "> " 'font-lock-face 'sly-mrepl-prompt-face)))

(with-eval-after-load 'sly-mrepl
  (if (boundp 'sly-mrepl-prompt-formatter)
      (setq sly-mrepl-prompt-formatter
            #'boogs/sly-new-prompt)
    (advice-add 'sly-mrepl--insert-prompt :around #'boogs/sly-prepare-prompt)))

(defun boogs/sly-end-of-prompt-p ()
  (and (not (= (point) (point-min)))
       (not (get-text-property (point) 'sly-mrepl--prompt))
       (get-text-property (1- (point)) 'sly-mrepl--prompt)))

(defun boogs/sly-prompt-line-p ()
  (or (boogs/sly-end-of-prompt-p)
      (save-excursion
        (goto-char (line-beginning-position))
        (boogs/sly-end-of-prompt-p))))

(defun boogs/sly-mrepl-previous-prompt ()
  "Go to the beginning of the previous REPL prompt."
  (interactive)
  (cl-flet ((go-back ()
                     (goto-char
                      (previous-single-char-property-change
                       (point) 'sly-mrepl--prompt))))
    (if (boogs/sly-prompt-line-p)
        (progn
          (unless (boogs/sly-end-of-prompt-p)
            (goto-char (line-beginning-position)))
          (go-back)
          (go-back))
      (go-back))
    (unless (boogs/sly-prompt-line-p)
      ;; We did not end up on a prompt, means we are above the first prompt.
      ;; Return back.
      (boogs/sly-mrepl-next-prompt))))

(defun boogs/sly-mrepl-next-prompt ()
  "Go to the beginning of the next REPL prompt."
  (interactive)
  (let ((pos (next-single-char-property-change (line-beginning-position 2)
                                               'sly-mrepl--prompt)))
    (goto-char pos)
    (if (get-text-property (point) 'sly-mrepl--prompt)
        (goto-char (next-single-char-property-change (point)
                                                     'sly-mrepl--prompt))
      (point))))

(advice-add 'sly-mrepl-next-prompt :override #'boogs/sly-mrepl-next-prompt)
(advice-add 'sly-mrepl-previous-prompt :override #'boogs/sly-mrepl-previous-prompt)

(defun sly-mrepl-return-at-end ()
  (interactive)
  (if (<= (point-max) (point))
      (sly-mrepl-return)
      (newline-and-indent)))

(require 'init-sly-narrow)

(provide 'init-sly)
